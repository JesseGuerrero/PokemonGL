<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Full Viewport</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #webgl-canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            background-color: #000;
        }
    </style>
</head>
<body>
    <canvas id="webgl-canvas"></canvas>

    <script>
        // Get the canvas element
        const canvas = document.getElementById('webgl-canvas');

        // Get WebGL context
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL not supported in this browser');
            throw new Error('WebGL not supported');
        }

        // Grid configuration
        const GRID_SIZE_INCHES = 0.75; // 3/4 inch per grid cell
        let gridSizePixels = 0;
        let gridCountX = 0;
        let gridCountY = 0;

        // Function to calculate DPI
        function calculateDPI() {
            // Create a temporary element to measure DPI
            const testDiv = document.createElement('div');
            testDiv.style.width = '1in';
            testDiv.style.height = '1in';
            testDiv.style.position = 'absolute';
            testDiv.style.left = '-100%';
            testDiv.style.top = '-100%';
            document.body.appendChild(testDiv);

            const dpi = testDiv.offsetWidth;
            document.body.removeChild(testDiv);

            return dpi;
        }

        // Function to resize canvas and recalculate grid
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);

            // Calculate grid size in pixels based on DPI
            const dpi = calculateDPI();
            gridSizePixels = GRID_SIZE_INCHES * dpi;

            // Calculate how many grid cells fit in each dimension
            gridCountX = Math.floor(canvas.width / gridSizePixels);
            gridCountY = Math.floor(canvas.height / gridSizePixels);

            console.log('DPI:', dpi);
            console.log('Grid size (pixels):', gridSizePixels);
            console.log('Grid count:', gridCountX, 'x', gridCountY);
        }

        // Vertex shader source
        const vertexShaderSource = `
            attribute vec2 a_position;
            uniform vec2 u_resolution;

            void main() {
                // Convert from pixels to clip space
                vec2 clipSpace = ((a_position / u_resolution) * 2.0) - 1.0;
                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
            }
        `;

        // Fragment shader source
        const fragmentShaderSource = `
            precision mediump float;
            uniform vec4 u_color;

            void main() {
                gl_FragColor = u_color;
            }
        `;

        // Function to create shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // Function to create program
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }

            return program;
        }

        // Create shaders and program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        // Get attribute and uniform locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const colorLocation = gl.getUniformLocation(program, 'u_color');

        // Create buffer for line positions
        const positionBuffer = gl.createBuffer();

        // Function to generate grid lines
        function generateGridLines() {
            const lines = [];

            // Vertical lines
            for (let i = 0; i <= gridCountX; i++) {
                const x = i * gridSizePixels;
                lines.push(x, 0, x, canvas.height);
            }

            // Horizontal lines
            for (let i = 0; i <= gridCountY; i++) {
                const y = i * gridSizePixels;
                lines.push(0, y, canvas.width, y);
            }

            return new Float32Array(lines);
        }

        // Function to draw grid
        function drawGrid() {
            // Clear canvas
            gl.clearColor(0.0, 0.1, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Use our shader program
            gl.useProgram(program);

            // Set resolution uniform
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

            // Set grid color (light gray)
            gl.uniform4f(colorLocation, 0.3, 0.3, 0.3, 1.0);

            // Generate and bind grid lines
            const gridLines = generateGridLines();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, gridLines, gl.STATIC_DRAW);

            // Enable position attribute
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Draw all lines
            gl.drawArrays(gl.LINES, 0, gridLines.length / 2);
        }

        // Initial setup
        resizeCanvas();

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            drawGrid();
        });

        // Render loop
        function render() {
            drawGrid();
            requestAnimationFrame(render);
        }

        // Start rendering
        render();

        // Log WebGL info for debugging
        console.log('WebGL Version:', gl.getParameter(gl.VERSION));
        console.log('WebGL Vendor:', gl.getParameter(gl.VENDOR));
        console.log('WebGL Renderer:', gl.getParameter(gl.RENDERER));
    </script>
</body>
</html>