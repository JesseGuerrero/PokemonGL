<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Full Viewport</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/render.css') }}">
</head>
<body>
    <canvas id="webgl-canvas"></canvas>

    <script>
        // Get the canvas element
        const canvas = document.getElementById('webgl-canvas');

        // Get WebGL context
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL not supported in this browser');
            throw new Error('WebGL not supported');
        }

        // Grid configuration
        const GRID_SIZE_INCHES = 0.75; // 3/4 inch per grid cell
        let gridSizePixels = 0;
        let gridCountX = 0;
        let gridCountY = 0;

        // Function to calculate DPI
        function calculateDPI() {
            // Create a temporary element to measure DPI
            const testDiv = document.createElement('div');
            testDiv.style.width = '1in';
            testDiv.style.height = '1in';
            testDiv.style.position = 'absolute';
            testDiv.style.left = '-100%';
            testDiv.style.top = '-100%';
            document.body.appendChild(testDiv);

            const dpi = testDiv.offsetWidth;
            document.body.removeChild(testDiv);

            return dpi;
        }

        // Function to resize canvas and recalculate grid
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);

            // Calculate grid size in pixels based on DPI
            const dpi = calculateDPI();
            gridSizePixels = GRID_SIZE_INCHES * dpi;

            // Calculate how many grid cells fit in each dimension
            gridCountX = Math.floor(canvas.width / gridSizePixels);
            gridCountY = Math.floor(canvas.height / gridSizePixels);

            console.log('DPI:', dpi);
            console.log('Grid size (pixels):', gridSizePixels);
            console.log('Grid count:', gridCountX, 'x', gridCountY);
        }

        // Function to load shader source from file
        async function loadShaderSource(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to load shader: ${response.status}`);
                }
                return await response.text();
            } catch (error) {
                console.error('Error loading shader:', error);
                throw error;
            }
        }

        // Function to create shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // Function to create program
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }

            return program;
        }

        // Initialize shaders and program
        let program;
        async function initShaders() {
            try {
                // Load shader sources
                const vertexShaderSource = await loadShaderSource('{{ url_for("static", filename="shaders/vertex.glsl") }}');
                const fragmentShaderSource = await loadShaderSource('{{ url_for("static", filename="shaders/fragment.glsl") }}');

                // Create shaders and program
                const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
                program = createProgram(gl, vertexShader, fragmentShader);

                if (!program) {
                    throw new Error('Failed to create shader program');
                }

                console.log('Shaders loaded successfully');
            } catch (error) {
                console.error('Failed to initialize shaders:', error);
                throw error;
            }
        }

        // Get attribute and uniform locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const colorLocation = gl.getUniformLocation(program, 'u_color');

        // Create buffer for line positions
        const positionBuffer = gl.createBuffer();

        // Function to generate grid lines
        function generateGridLines() {
            const lines = [];

            // Vertical lines
            for (let i = 0; i <= gridCountX; i++) {
                const x = i * gridSizePixels;
                lines.push(x, 0, x, canvas.height);
            }

            // Horizontal lines
            for (let i = 0; i <= gridCountY; i++) {
                const y = i * gridSizePixels;
                lines.push(0, y, canvas.width, y);
            }

            return new Float32Array(lines);
        }

        // Function to draw grid
        function drawGrid() {
            // Clear canvas
            gl.clearColor(0.0, 0.1, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Use our shader program
            gl.useProgram(program);

            // Set resolution uniform
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

            // Set grid color (light gray)
            gl.uniform4f(colorLocation, 0.3, 0.3, 0.3, 1.0);

            // Generate and bind grid lines
            const gridLines = generateGridLines();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, gridLines, gl.STATIC_DRAW);

            // Enable position attribute
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Draw all lines
            gl.drawArrays(gl.LINES, 0, gridLines.length / 2);
        }

        // Initialize everything
        async function init() {
            try {
                // Initial setup
                resizeCanvas();

                // Load shaders
                await initShaders();

                // Handle window resize
                window.addEventListener('resize', () => {
                    resizeCanvas();
                    drawGrid();
                });

                // Start rendering
                render();
            } catch (error) {
                console.error('Initialization failed:', error);
                alert('Failed to initialize WebGL application. Check console for details.');
            }
        }

        // Render loop
        function render() {
            if (program) {
                drawGrid();
            }
            requestAnimationFrame(render);
        }

        // Start the application
        init();

        // Log WebGL info for debugging
        console.log('WebGL Version:', gl.getParameter(gl.VERSION));
        console.log('WebGL Vendor:', gl.getParameter(gl.VENDOR));
        console.log('WebGL Renderer:', gl.getParameter(gl.RENDERER));
    </script>
</body>
</html>